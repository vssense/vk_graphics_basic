#version 450

#define SIZE 16

const float OFFSETS[SIZE] = float[SIZE](
    -14.1684792568739,
    -12.201613265873693,
    -10.239385576926011,
    -8.281739853232981,
    -6.328357272092126,
    -4.378621204796657,
    -2.431625915613778,
    -0.4862426846689485,
    1.4588111840004858,
    3.4048471718931532,
    5.35308381175656,
    7.304547036499911,
    9.260003189282239,
    11.219917592867032,
    13.184471765481433,
    15
);

const float WEIGHTS[SIZE] = float[SIZE](
    0.000003281430565163154,
    0.00005983100517975895,
    0.0007078188777397442,
    0.005438630907027542,
    0.027166775985508103,
    0.08829613588333014,
    0.1868650174755795,
    0.25764635938674746,
    0.23148789069489062,
    0.135521130800376,
    0.051677156878404566,
    0.012826760287632577,
    0.0020706563208671867,
    0.00021720991123181217,
    0.000014791301936858163,
    5.528529831019881e-7
);


layout (binding = 0) uniform sampler2D original_image;
layout (binding = 1, rg32f) uniform writeonly image2D blurred_image;

// blur_direction is:
//     vec2(1,0) for horizontal pass
//     vec2(0,1) for vertical pass
// The source texture to be blurred MUST use linear filtering!
// pixel_coord is in [0..1]
vec4 blur(vec2 blur_direction, vec2 pixel_coord, vec2 size) {
    vec2 result = vec2(0.0);
    for (int i = 0; i < SIZE; ++i) {
        vec2 offset = blur_direction * OFFSETS[i] / size;
        float weight = WEIGHTS[i];
        result += texture(original_image, pixel_coord + offset).xy * weight;
    }

    return vec4(result, 0.0, 0.0);
}

layout(push_constant) uniform params_t
{
    vec2 direction;
};

layout(local_size_x = 32, local_size_y = 32) in;
void main() {
    ivec2 size = textureSize(original_image, 0);
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    if (coords.x < size.x && coords.y < size.y) {
        vec2 f_size = vec2(size);
        vec2 f_coords = vec2(coords) / f_size;

        imageStore(blurred_image, coords, blur(direction, f_coords, f_size));
    }
}
